<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>nimler</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="extras/custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="nimler_mix.html"><strong aria-hidden="true">1.2.</strong> Using nimler_mix</a></li><li class="chapter-item expanded "><a href="tests.html"><strong aria-hidden="true">1.3.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="example_basic.html"><strong aria-hidden="true">2.1.</strong> Basic - add numbers</a></li><li class="chapter-item expanded "><a href="example_tests.html"><strong aria-hidden="true">2.2.</strong> Nimler tests</a></li></ol></li><li class="chapter-item expanded "><a href="guide.html"><strong aria-hidden="true">3.</strong> Developer guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="codec.html"><strong aria-hidden="true">3.1.</strong> Erlang term conversion</a></li><li class="chapter-item expanded "><a href="gen_wrappers.html"><strong aria-hidden="true">3.2.</strong> Generating wrapper module</a></li><li class="chapter-item expanded "><a href="nif_versions.html"><strong aria-hidden="true">3.3.</strong> Erlang/OTP versioning</a></li><li class="chapter-item expanded "><a href="nim_docs.html"><strong aria-hidden="true">3.4.</strong> Nim docs - generated</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">nimler</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#nimler" id="nimler">nimler</a></h1>
<p>Nimler is a library for authoring Erlang and Elixir NIFs in the nim programming language. It has mostly complete bindings for the Erlang NIF API and some accessories for making writing NIFs easier, including idiomatic functions for converting between Erlang terms and nim types, and simplifications for using resource objects.</p>
<p>Mostly, Nimler is a minimal, zero-dependency wrapper for Erlang <a href="https://erlang.org/doc/man/erl_nif.html">NIF API</a>.</p>
<table><thead><tr><th>Target</th><th>Status</th></tr></thead><tbody>
<tr><td>x86_64-linux</td><td><img src="https://github.com/wltsmrz/nimler/workflows/build-x64/badge.svg" alt="" /></td></tr>
<tr><td>arm64-linux</td><td><img src="https://github.com/wltsmrz/nimler/workflows/build-arm64/badge.svg" alt="" /></td></tr>
</tbody></table>
<h2><a class="header" href="#sample" id="sample">Sample</a></h2>
<p>Positional API sample:</p>
<pre><code class="language-nim">import nimler

using
  env: ptr ErlNifEnv

func add(env; a: int, b: int): (ErlAtom, int) {.xnif.} =
  (AtomOk, a + b)
  
func sub(env; a: int, b: int): (ErlAtom, int) {.xnif.} =
  (AtomOk, a - b)

func mul(env; a: int, b: int): (ErlAtom, int) {.xnif.} =
  (AtomOk, a * b)
  
exportNifs &quot;Elixir.NifMath&quot;, [ add, sub, mul ]
</code></pre>
<h2><a class="header" href="#raw-api" id="raw-api">Raw API</a></h2>
<p>If porting a NIF from C, it may be easier to start with the raw API, which
retains NIF signature:</p>
<pre><code class="language-nim">import nimler

using
  env: ptr ErlNifEnv
  argc: cint
  argv: ptr UncheckedArray[ErlNifTerm]

func add(env, argc, argv): ErlNifTerm {.nif, arity: 2.} =
  # `fromTerm(env, term, to_type)` returns a nim Option.
  let a1 = fromTerm(env, argv[0], int).get(0)
  let a2 = fromTerm(env, argv[1], int).get(0)
  return toTerm(env, a1 + a2)
  
# Specify external NIF name. In this case, the function is exported as &quot;sub&quot;
# rather than &quot;subnums&quot; 
func subnums(env, argc, argv): ErlNifTerm {.nif, arity: 2, name: &quot;sub&quot;.} =
  let a1 = fromTerm(env, argv[0], int).get(0)
  let a2 = fromTerm(env, argv[1], int).get(0)
  return toTerm(env, a1 - a2)

# This NIF is tagged with `dirty_cpu`. See the documentation for details on
# using dirty schedulers: https://erlang.org/doc/man/erl_nif.html#functionality
func mul(env, argc, argv): ErlNifTerm {.nif, arity: 2, dirty_cpu.} =
  let a1 = fromTerm(env, argv[0], int).get(0)
  let a2 = fromTerm(env, argv[1], int).get(1)
  return toTerm(env, a1 * a2)

# Optional `{.raises: [].}` pragma is part of nim's effect system. This verifies
# that the NIF does not raise an exception
func div(env, argc, argv): ErlNifTerm {.nif, arity: 2, raises: [].} =
  let a1 = fromTerm(env, argv[0], int).get(0)
  let a2 = fromTerm(env, argv[1], int)

  if a2 == some(0.int):
    return enif_make_badarg(env)

  return toTerm(env, a1 div a2.unsafeGet())
  
exportNifs(&quot;Elixir.NifMath&quot;, [
  add,
  subnums,
  mul,
  div
])
</code></pre>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<h2><a class="header" href="#supported-platforms" id="supported-platforms">Supported platforms</a></h2>
<p>Continuous integration is run on x86-64 and arm64 linux. Other platforms are not
currently tested, although MacOS likely works. Windows likely does not work.</p>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Nim</strong> v1.2.0+. See: <a href="https://nim-lang.org/install_unix.html">installation guide</a></li>
<li><strong>Erlang/OTP</strong>
<ul>
<li>Ubuntu: <code>apt-get install erlang-dev</code></li>
<li>MacOS: <code>brew install erlang</code></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#installing-nimler" id="installing-nimler">Installing nimler</a></h2>
<p>Nimler can be installed via nim package manager <code>nimble</code>:</p>
<pre><code class="language-bash">$ nimble install nimler
</code></pre>
<h1><a class="header" href="#using-nimler_mix" id="using-nimler_mix">Using nimler_mix</a></h1>
<p>Github: <a href="https://github.com/wltsmrz/nimler_mix">nimler_mix</a></p>
<p>Nim and nimler must first be installed. See <a href="./installation.html">installation</a>.</p>
<ol>
<li>Add <code>nimler</code> to mix.exs and run <code>mix deps.get</code> to install nimler from hex.pm</li>
</ol>
<pre><code class="language-elixir">  def deps() do
    [{:nimler, &quot;~&gt; 0.1.1&quot;}]
  end
</code></pre>
<ol start="2">
<li>
<p><code>mix nimler.new</code> to generate scaffold NIF project</p>
</li>
<li>
<p><code>mix compile.nimler</code> to compile NIF with nimler</p>
</li>
</ol>
<h2><a class="header" href="#mix-nimlernew" id="mix-nimlernew">mix nimler.new</a></h2>
<p>Generate basic nimler NIF</p>
<p><strong>Defaults</strong></p>
<p><code>lib/native</code> is default NIF root</p>
<p><code>lib/native/nif.nim</code> is default NIF file</p>
<p><code>lib/native/nim.cfg</code> is default NIF nim configuration. This will be used during compilation. See <a href="https://github.com/wltsmrz/nimler_mix/blob/master/priv/templates/nim.cfg">priv/templates/nim.cfg</a> for current nim.cfg template</p>
<h2><a class="header" href="#mix-compilenimler" id="mix-compilenimler">mix compile.nimler</a></h2>
<p>Compile NIFs in <code>lib/native</code></p>
<p>Nimler generates <code>lib/native/nif_wrapper.ex</code> by default</p>
<p><strong>Configuration sample</strong></p>
<pre><code class="language-elixir">  def project do
    [
      app: :myproject,
      version: &quot;0.1.0&quot;,
      elixir: &quot;~&gt; 1.10&quot;,
      start_permanent: Mix.env() == :prod,
      deps: deps(),

      # add the nimler compiler
      compilers: Mix.compilers ++ [:nimler],

      # add optional nimler_config
      nimler_config: nimler_config()
    ]
  end

  def nimler_config() do
    [
      # compile_mode can be one of :debug, :release, :danger
      compile_mode: :debug,

      # compile_flags are passed directly to nim compiler
      # see [priv/templates/nim.cfg](priv/templates/nim.cfg) for default nim cfg
      compile_flags: [
        &quot;--verbosity:2&quot;
      ]
    ]
  end

  def deps() do
    [{:nimler, &quot;~&gt; 0.1.1&quot;}]
  end

</code></pre>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>Nimler <a href="https://github.com/wltsmrz/nimler/tree/develop/tests">tests</a> are Elixir NIFs. Elixir is required to run tests.</p>
<pre><code class="language-bash">$ git clone git@github.com:wltsmrz/nimler.git
$ cd nimler
$ nimble build_all # build all test NIFs
$ nimble test_all # run tests
</code></pre>
<h2><a class="header" href="#build-status" id="build-status">Build status</a></h2>
<p>Automated tests are run via github actions on Ubuntu x64 and arm64.</p>
<table><thead><tr><th>Target</th><th>Status</th></tr></thead><tbody>
<tr><td>x86_64-linux</td><td><img src="https://github.com/wltsmrz/nimler/workflows/build-x64/badge.svg" alt="" /></td></tr>
<tr><td>arm64-linux</td><td><img src="https://github.com/wltsmrz/nimler/workflows/build-arm64/badge.svg" alt="" /></td></tr>
</tbody></table>
<h2><a class="header" href="#nim-compile-flags" id="nim-compile-flags">Nim compile flags</a></h2>
<p>As NIFs are shared libraries, the minimum required configuration is <code>--app:lib</code>.
Automated tests are run with the following nim.cfg:</p>
<pre><code>define:nimlerGenWrapperForce
define:nimlerWrapperFilename=&quot;NimlerWrapper.ex&quot;
define:release
verbosity:0
app:lib
gc:arc
define:forceBuild
define:noMain
define:noSignalHandler 
opt:speed
stackTrace:off
lineTrace:off
panics:on
warning[GcUnsafe]:off
hint[User]:off
hint[Exec]:off
hint[Link]:off
hint[SuccessX]:off
hint[Conf]:off
hint[Processing]:off
hint[GCStats]:off
hint[GlobalVar]:off
</code></pre>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<h1><a class="header" href="#basic" id="basic">Basic</a></h1>
<p>Basic example to create <code>add(a, b)</code> NIF. We will use nimler to automatically generate Elixir wrapper module, then test via elixir CLI.</p>
<pre><code class="language-nim">import nimler
import nimler/codec

func add(env: ptr ErlNifEnv, a1: int, a2: int): int {.xnif.} =
  return a1 + a2

exportNifs &quot;Elixir.NumberAdder&quot;, [ add ]
</code></pre>
<ol>
<li>
<p><strong>Compile</strong> <code>nim c --app:lib -d:nimlerGenWrapper nif.nim</code>. Produces <code>libnif.so</code> and <code>NumberAdder.ex</code></p>
</li>
<li>
<p><strong>Run</strong> <code>elixir -r NumberAdder.ex -e &quot;IO.inspect %{add: NumberAdder.add(1, 2)}&quot;</code></p>
</li>
</ol>
<blockquote>
<p><strong>Note:</strong> <code>exportNifs()</code> is a compile-time template that exports an <code>ErlNifEntry</code> to be loaded by Erlang or Elixir</p>
</blockquote>
<h1><a class="header" href="#nimler-tests" id="nimler-tests">Nimler tests</a></h1>
<p>The tests for nimler itself are Elixir NIFs.</p>
<ul>
<li><a href="https://github.com/wltsmrz/nimler/blob/develop/tests/integration/nif.nim">tests/integration</a> erl_nif.h binding coverage</li>
<li><a href="https://github.com/wltsmrz/nimler/blob/develop/tests/codec/nif.nim">tests/codec</a> conversion between Erlang terms and nim types</li>
<li><a href="https://github.com/wltsmrz/nimler/tree/develop/tests/positional/nif.nim">tests/positional</a> positional API tests</li>
<li><a href="https://github.com/wltsmrz/nimler/blob/develop/tests/message/nif.nim">tests/message</a> message passing to Elixir process</li>
<li><a href="https://github.com/wltsmrz/nimler/blob/develop/tests/timeslice/nif.nim">tests/timeslice</a> NIF yielding with enif_schedule_nif </li>
</ul>
<h1><a class="header" href="#developer-guide" id="developer-guide">Developer guide</a></h1>
<ul>
<li><a href="https://smrz.dev/nimler/codec.html">converting between nim and erlang types</a></li>
<li><a href="https://smrz.dev/nimler/gen_wrappers.html">generating wrapper modules
automatically</a></li>
<li><a href="https://smrz.dev/nimler/nif_versions.html">specifying erl_nif target version</a></li>
</ul>
<h1><a class="header" href="#erlang-term-conversion" id="erlang-term-conversion">Erlang term conversion</a></h1>
<p>Erlang/Elixir terms are represented in nimler with the opaque type <code>ErlNifTerm</code>. Nimler
exposes functions for converting between nim types and Erlang terms.</p>
<h2><a class="header" href="#fromterm" id="fromterm">fromTerm()</a></h2>
<p><code>fromTerm()</code> produces nim type from <code>ErlNifTerm</code>. <code>fromTerm()</code> returns an <a href="https://nim-lang.org/docs/options.html">Option</a>.</p>
<pre><code class="language-nim">let i_option = env.fromTerm(term, int32)

if i_option.isNone():
  # The term was not successfully read into an int32
else:
  let i = i_option.get()

# Default value of 0 if term is not read successfully
let ii = env.fromTerm(term, int32).get(0)
</code></pre>
<h2><a class="header" href="#toterm" id="toterm">toTerm()</a></h2>
<p><code>toTerm()</code> produces <code>ErlNifTerm</code> from nim type.</p>
<pre><code class="language-nim">let term = env.toTerm(10)
let other_term = env.toTerm(10'i32)
</code></pre>
<h2><a class="header" href="#supported-types" id="supported-types">Supported Types</a></h2>
<table><thead><tr><th>Erlang</th><th>Elixir</th><th>Nimler</th></tr></thead><tbody>
<tr><td>Integer</td><td>Integer</td><td>int, int32, int64, uint, uint32, uint64</td></tr>
<tr><td>Float</td><td>Float</td><td>float</td></tr>
<tr><td>Atom</td><td>Atom</td><td>distinct string</td></tr>
<tr><td>Atom</td><td>Atom</td><td>bool</td></tr>
<tr><td>String</td><td>Charlist</td><td>seq[char]</td></tr>
<tr><td>Bitstring</td><td>String</td><td>string</td></tr>
<tr><td>Binary</td><td>Binary</td><td>seq[byte]</td></tr>
<tr><td>List</td><td>List</td><td>seq[T]</td></tr>
<tr><td>Tuple</td><td>Tuple</td><td>tuple</td></tr>
<tr><td>Map</td><td>Map</td><td>Table[A, B]</td></tr>
<tr><td>PID</td><td>PID</td><td>ErlPid</td></tr>
<tr><td>Term</td><td>Term</td><td>ErlTerm</td></tr>
</tbody></table>
<h3><a class="header" href="#atoms" id="atoms">Atoms</a></h3>
<pre><code class="language-nim">let term = env.toTerm(ErlAtom(&quot;test&quot;))
# :test

let atom = env.fromTerm(term, ErlAtom).get()
# ErlAtom(&quot;test&quot;)
</code></pre>
<blockquote>
<p><strong>Note:</strong>
The following atom constants are exported from nimler. Note that these are not yet converted to <code>ErlNifTerm</code>:</p>
<ul>
<li><code>AtomOk</code> = <code>ErlAtom(&quot;ok&quot;)</code></li>
<li><code>AtomError</code> = <code>ErlAtom(&quot;error&quot;)</code></li>
<li><code>AtomTrue</code> = <code>ErlAtom(&quot;true&quot;)</code></li>
<li><code>AtomFalse</code> = <code>ErlAtom(&quot;false&quot;)</code></li>
</ul>
</blockquote>
<h3><a class="header" href="#booleans" id="booleans">Booleans</a></h3>
<pre><code class="language-nim">let term = env.toTerm(true)
# :true

let atom = env.fromTerm(term, bool).get()
# true
</code></pre>
<h3><a class="header" href="#charlists" id="charlists">Charlists</a></h3>
<pre><code class="language-nim">let term = env.toTerm(@&quot;test&quot;)
# 'test'

let lst = env.fromTerm(term, seq[char]).get()
# @['t', 'e', 's', 't']
</code></pre>
<h3><a class="header" href="#strings" id="strings">Strings</a></h3>
<p>Strings follow the Elixir pattern of using Erlang bitstring rather than charlists</p>
<pre><code class="language-nim">let term = env.toTerm(&quot;test&quot;)
# &quot;test&quot;

let str = env.fromTerm(term, string).get()
# &quot;test&quot;
</code></pre>
<h3><a class="header" href="#binaries" id="binaries">Binaries</a></h3>
<pre><code class="language-nim">let term = env.toTerm(toOpenArrayByte(&quot;test&quot;, 0, 3))
# &lt;&lt;116, 101, 115, 116&gt;&gt;

let bin = env.fromTerm(term, seq[byte]).get()
# @[116, 101, 115, 116]
</code></pre>
<h3><a class="header" href="#lists" id="lists">Lists</a></h3>
<p>Elements of <code>seq</code> must be of the same type.</p>
<pre><code class="language-nim">let term = env.toTerm(@[1,2,3])
# [1,2,3]

let lst = env.fromTerm(term, seq[int]).get()
# @[1,2,3]
</code></pre>
<h3><a class="header" href="#tuples" id="tuples">Tuples</a></h3>
<p>Tuples in nim may contain mixed types.</p>
<pre><code class="language-nim">let term = env.toTerm((&quot;test&quot;,1,3.14))
# {&quot;test&quot;,1,3.14}

let (a,b,c) = env.fromTerm(term, (string, int, float)).get()
# a=&quot;test&quot;
# b=1
# c=3.14
</code></pre>
<h3><a class="header" href="#keyword-lists" id="keyword-lists">Keyword lists</a></h3>
<p>Keyword lists (lists of {Atom, <term>}) are represented with the type <code>ErlKeywords</code>. Passing generic <code>object</code> types
to <code>fromTerm()</code> or <code>toTerm()</code> also implies keyword list.</p>
<pre><code class="language-nim">type MyObj = object
  a: int
  b: float
  c: string

let term = toTerm(env, MyObj(a: 1, b: 1.1, c: &quot;test&quot;))
# keyword list: [a: 1, b: 1.1, c: &lt;&lt;&quot;test&quot;&gt;&gt;]

let o = fromTerm(env, term, MyObj).get()
# MyObj{a,b,c}
</code></pre>
<h3><a class="header" href="#maps" id="maps">Maps</a></h3>
<p>Maps are represented in nimler with the <code>Table[K, V]</code> type.</p>
<pre><code class="language-nim">import tables

var t = initTable[string, int](4)
t[&quot;a&quot;] = 1
t[&quot;b&quot;] = 2

let term = env.toTerm(t)
# %{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2}

let tt = env.fromTerm(term, Table[string, int]).get()
# {&quot;a&quot;: 1, &quot;b&quot;: 2}
</code></pre>
<h3><a class="header" href="#opaque-terms" id="opaque-terms">Opaque terms</a></h3>
<p>Sometimes specifying opaque <code>ErlTerm</code> type is convenient. Example with the
positional nimler API:</p>
<pre><code class="language-nim">func addThing(env: ptr ErlNifEnv, myArg: ErlTerm): ErlTerm {.xnif.} =
  # fromTerm(env, myArg, int).get()
  # fromTerm(env, myArg, string).get()
  # fromTerm(env, myArg, seq[byte]).get()
</code></pre>
<h3><a class="header" href="#pids" id="pids">PIDs</a></h3>
<p>Process IDs are represented in nimler with the <code>ErlPid</code> type.</p>
<pre><code class="language-nim">let pid = fromTerm(env, term, ErlPid).get()
</code></pre>
<h3><a class="header" href="#results" id="results">Results</a></h3>
<p>Result tuples have a first element either <code>:ok</code> or <code>:error</code>. Nimler functions <code>env.ok()</code> and <code>env.error()</code> accept varargs.</p>
<pre><code class="language-nim">let ok_term = env.ok(env.toTerm(1), env.toTerm(2))
# {:ok, 1, 2}

let err_term = env.error(env.toTerm(&quot;Bad thing&quot;))
# {:error, &quot;Bad thing&quot;}
</code></pre>
<h1><a class="header" href="#generating-wrapper-module" id="generating-wrapper-module">Generating wrapper module</a></h1>
<p>Nimler can generate Erlang or Elixir wrapper at compile time.</p>
<p>Relevant nim compile flags:</p>
<p><code>-d:nimlerGenWrapper</code> - generate elixir wrapper</p>
<p><code>-d:nimlerGenWrapperForce</code> - potentially overwrite existing wrapper of the same</p>
<p><code>-d:nimlerWrapperRoot=/myroot</code> - absolute root directory of the generated wrapper</p>
<p><code>-d:nimlerWrapperFilename=Wrapper.ex</code> - file name of the generated wrapper</p>
<p><code>-d:nimlerWrapperLoadInfo={a: 123}</code> - module load info</p>
<p><code>-d:nimlerWrapperType=elixir</code> - possible values <code>erlang</code>, <code>elixir</code>. Note: to
generate erlang wrappers, also remove any <code>Elixir.xxxx</code> prefixes in the call to
<code>exportNifs() template</code></p>
<p>The name of the target Elixir module, and its filename, is based on the module name as exported from nimler and not the name of the .nim source file. <code>export_nifs(&quot;Elixir.NumberAdder&quot;, ...</code> will produce module named <code>NumberAdder</code>.</p>
<p>The target directory is the same as the .nim source. i.e., -o nim compile flag affects the destination of generated Elixir module. Override with <code>-d:nimlerWrapperRoot</code>.</p>
<h1><a class="header" href="#erlangotp-versioning" id="erlangotp-versioning">Erlang/OTP versioning</a></h1>
<p>Erlang/Elixir NIFs are shared libraries that depend on erl_nif.h. Nimler automatically detects installed Erlang/OTP, and tries to produce bindings that are compatible with the Erlang NIF API version detected at compile time.</p>
<p>Using an unsupported function will err during compilation:</p>
<pre><code>Error: enif_term_type() not supported in target NIF version: 2.10.
Requires at least version 2.15.
</code></pre>
<h2><a class="header" href="#target-specific-erl_nif-version" id="target-specific-erl_nif-version">Target specific erl_nif version</a></h2>
<p>To target a specific version of erl_nif API, compile with: <code>--define:nif_version=&quot;x.y&quot;</code>.</p>
<h1><a class="header" href="#nim-docs" id="nim-docs">Nim docs</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="extras/highlight.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
